// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using MarkitComposition;
//
//    var markitCompositionObject = MarkitCompositionObject.FromJson(jsonString);

namespace MarkitComposition
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class MarkitCompositionObject
    {
        [JsonProperty("meta")]
        public Meta Meta { get; set; }

        [JsonProperty("result")]
        public Result Result { get; set; }
    }

    public partial class Meta
    {
        [JsonProperty("params")]
        public Params Params { get; set; }

        [JsonProperty("restrictions")]
        public Restrictions Restrictions { get; set; }

        [JsonProperty("apiVersion")]
        public string ApiVersion { get; set; }

        [JsonProperty("path")]
        public string Path { get; set; }

        [JsonProperty("lic")]
        public long Lic { get; set; }

        [JsonProperty("received")]
        public string Received { get; set; }

        [JsonProperty("node")]
        public string Node { get; set; }

        [JsonProperty("returned")]
        public string Returned { get; set; }
    }

    public partial class Params
    {
        [JsonProperty("securityId")]
        public long SecurityId { get; set; }

        [JsonProperty("asAt")]
        public string AsAt { get; set; }

        [JsonProperty("isOpen")]
        public long IsOpen { get; set; }

        [JsonProperty("lenient")]
        public long Lenient { get; set; }

        [JsonProperty("user")]
        public User User { get; set; }
    }

    public partial class User
    {
        [JsonProperty("password")]
        public object Password { get; set; }

        [JsonProperty("username")]
        public string Username { get; set; }

        [JsonProperty("authorities")]
        public Authority[] Authorities { get; set; }

        [JsonProperty("accountNonExpired")]
        public bool AccountNonExpired { get; set; }

        [JsonProperty("accountNonLocked")]
        public bool AccountNonLocked { get; set; }

        [JsonProperty("credentialsNonExpired")]
        public bool CredentialsNonExpired { get; set; }

        [JsonProperty("enabled")]
        public bool Enabled { get; set; }

        [JsonProperty("licenseID")]
        public long LicenseId { get; set; }

        [JsonProperty("rawData")]
        public RawData RawData { get; set; }
    }

    public partial class Authority
    {
        [JsonProperty("authority")]
        public string AuthorityAuthority { get; set; }
    }

    public partial class RawData
    {
        [JsonProperty("userID")]
        public long UserId { get; set; }

        [JsonProperty("userName")]
        public string UserName { get; set; }

        [JsonProperty("firstName")]
        public string FirstName { get; set; }

        [JsonProperty("lastName")]
        public string LastName { get; set; }

        [JsonProperty("password")]
        public string Password { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("isAccountLocked")]
        public bool IsAccountLocked { get; set; }

        [JsonProperty("changePasswordNextLogin")]
        public bool ChangePasswordNextLogin { get; set; }

        [JsonProperty("accountExpiryDate")]
        public DateTimeOffset AccountExpiryDate { get; set; }

        [JsonProperty("passwordExpiryDate")]
        public DateTimeOffset PasswordExpiryDate { get; set; }

        [JsonProperty("resetTokenExpiryDate")]
        public object ResetTokenExpiryDate { get; set; }

        [JsonProperty("lastLogin")]
        public long LastLogin { get; set; }

        [JsonProperty("clientLicenseId")]
        public long ClientLicenseId { get; set; }

        [JsonProperty("loginAttempts")]
        public long LoginAttempts { get; set; }

        [JsonProperty("resetToken")]
        public string ResetToken { get; set; }

        [JsonProperty("roles")]
        public object[] Roles { get; set; }
    }

    public partial class Restrictions
    {
        [JsonProperty("GICS")]
        public bool Gics { get; set; }

        [JsonProperty("ICB")]
        public bool Icb { get; set; }
    }

    public partial class Result
    {
        [JsonProperty("hedgedCustomBasketDates")]
        public object[] HedgedCustomBasketDates { get; set; }

        [JsonProperty("indexProperties")]
        public IndexProperty[] IndexProperties { get; set; }

        [JsonProperty("factorDefinition")]
        public FactorDefinition FactorDefinition { get; set; }

        [JsonProperty("providerDividends")]
        public object[] ProviderDividends { get; set; }

        [JsonProperty("constituents")]
        public Constituent[] Constituents { get; set; }

        [JsonProperty("indexPositions")]
        public IndexPosition[] IndexPositions { get; set; }

        [JsonProperty("listings")]
        public Listing[] Listings { get; set; }

        [JsonProperty("header")]
        public Header[] Header { get; set; }

        [JsonProperty("hedgedCustomBasketCurrencies")]
        public object[] HedgedCustomBasketCurrencies { get; set; }

        [JsonProperty("constituentChanges")]
        public object[] ConstituentChanges { get; set; }
    }

    public partial class Constituent
    {
        [JsonProperty("SecurityID")]
        public long SecurityId { get; set; }

        [JsonProperty("ListingID")]
        public long ListingId { get; set; }

        [JsonProperty("Bloomberg")]
        public string Bloomberg { get; set; }

        [JsonProperty("ExchangeTicker")]
        public string ExchangeTicker { get; set; }

        [JsonProperty("Isin")]
        public string Isin { get; set; }

        [JsonProperty("Cusip")]
        public string Cusip { get; set; }

        [JsonProperty("Ric")]
        public string Ric { get; set; }

        [JsonProperty("AlternateRic")]
        public object AlternateRic { get; set; }

        [JsonProperty("ListingCurrency")]
        public Currency ListingCurrency { get; set; }

        [JsonProperty("Mic")]
        public string Mic { get; set; }

        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("SecurityType")]
        public ConstituentSecurityType SecurityType { get; set; }

        [JsonProperty("Sedol")]
        public string Sedol { get; set; }

        [JsonProperty("Other")]
        public string Other { get; set; }

        [JsonProperty("ConstituentType")]
        public ConstituentType ConstituentType { get; set; }

        [JsonProperty("PriceAdjustmentFactor")]
        public long PriceAdjustmentFactor { get; set; }

        [JsonProperty("Factor1")]
        public double? Factor1 { get; set; }

        [JsonProperty("Factor2")]
        public double? Factor2 { get; set; }

        [JsonProperty("Factor3")]
        public double? Factor3 { get; set; }

        [JsonProperty("Factor4")]
        public double? Factor4 { get; set; }

        [JsonProperty("Factor5")]
        public double? Factor5 { get; set; }

        [JsonProperty("Factor6")]
        public double? Factor6 { get; set; }

        [JsonProperty("Factor7")]
        public double? Factor7 { get; set; }

        [JsonProperty("Factor8")]
        public double? Factor8 { get; set; }

        [JsonProperty("Factor9")]
        public long? Factor9 { get; set; }

        [JsonProperty("IndexQuantity")]
        public double IndexQuantity { get; set; }

        [JsonProperty("NumberOfUnits")]
        public long NumberOfUnits { get; set; }

        [JsonProperty("Price")]
        public double Price { get; set; }

        [JsonProperty("PriceCurrency")]
        public Currency PriceCurrency { get; set; }

        [JsonProperty("UnadjustedPrice")]
        public double UnadjustedPrice { get; set; }

        [JsonProperty("FxRate")]
        public double FxRate { get; set; }

        [JsonProperty("BasketType")]
        public string BasketType { get; set; }

        [JsonProperty("AccruedInterest")]
        public object AccruedInterest { get; set; }

        [JsonProperty("CleanPrice")]
        public object CleanPrice { get; set; }

        [JsonProperty("GICS")]
        public string Gics { get; set; }

        [JsonProperty("GicsClassification")]
        public string GicsClassification { get; set; }

        [JsonProperty("ICB")]
        public string Icb { get; set; }

        [JsonProperty("DirtyPrice")]
        public object DirtyPrice { get; set; }

        [JsonProperty("DomicileCountryCode")]
        public string DomicileCountryCode { get; set; }

        [JsonProperty("DomicileCountry")]
        public string DomicileCountry { get; set; }

        [JsonProperty("BDR")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long? Bdr { get; set; }

        [JsonProperty("ProviderPrice")]
        public long ProviderPrice { get; set; }

        [JsonProperty("PctWeight")]
        public string PctWeight { get; set; }
    }

    public partial class FactorDefinition
    {
        [JsonProperty("Factor1")]
        public string Factor1 { get; set; }

        [JsonProperty("Factor2")]
        public string Factor2 { get; set; }
    }

    public partial class Header
    {
        [JsonProperty("BatchID")]
        public long? BatchId { get; set; }

        [JsonProperty("HasTPlus")]
        public long HasTPlus { get; set; }

        [JsonProperty("HasRebalance")]
        public long HasRebalance { get; set; }

        [JsonProperty("IsHeaderOnly")]
        public long IsHeaderOnly { get; set; }

        [JsonProperty("HasDividends")]
        public long HasDividends { get; set; }

        [JsonProperty("FxRateSet")]
        public string FxRateSet { get; set; }

        [JsonProperty("DataProvider")]
        public string DataProvider { get; set; }

        [JsonProperty("FundProvider")]
        public object FundProvider { get; set; }

        [JsonProperty("RebalanceNotes")]
        public object RebalanceNotes { get; set; }

        [JsonProperty("RebalanceFrequency")]
        public object RebalanceFrequency { get; set; }

        //[JsonProperty("NextRebalanceDate")]
        //public DateTimeOffset NextRebalanceDate { get; set; }

        [JsonProperty("PrimaryListingID")]
        public long PrimaryListingId { get; set; }

        [JsonProperty("BaseCurrency")]
        public Currency BaseCurrency { get; set; }

        [JsonProperty("TaxRateSetID")]
        public object TaxRateSetId { get; set; }

        [JsonProperty("TaxRateSetName")]
        public object TaxRateSetName { get; set; }

        [JsonProperty("DataExtractionSetID")]
        public object DataExtractionSetId { get; set; }
    }

    public partial class IndexPosition
    {
        [JsonProperty("ListingID")]
        public long ListingId { get; set; }

        [JsonProperty("Bloomberg")]
        public string Bloomberg { get; set; }

        [JsonProperty("ExchangeTicker")]
        public string ExchangeTicker { get; set; }

        [JsonProperty("Isin")]
        public Isin? Isin { get; set; }

        [JsonProperty("Cusip")]
        public string Cusip { get; set; }

        [JsonProperty("Ric")]
        public string Ric { get; set; }

        [JsonProperty("ListingCurrency")]
        public string ListingCurrency { get; set; }

        [JsonProperty("Mic")]
        public Mic Mic { get; set; }

        [JsonProperty("Name")]
        public Name Name { get; set; }

        [JsonProperty("SecurityType")]
        public IndexPositionSecurityType SecurityType { get; set; }

        [JsonProperty("Sedol")]
        public string Sedol { get; set; }

        ////[JsonProperty("Other")]
        ////public object Other { get; set; }

        [JsonProperty("AsAtDate")]
        public DateTimeOffset AsAtDate { get; set; }

        [JsonProperty("Value")]
        public double Value { get; set; }

        [JsonProperty("CalculatedIndexValue")]
        public double CalculatedIndexValue { get; set; }

        [JsonProperty("Cash")]
        public long Cash { get; set; }

        [JsonProperty("Divisor")]
        public long Divisor { get; set; }

        [JsonProperty("IsOpen")]
        public long IsOpen { get; set; }

        [JsonProperty("MarketCap")]
        public double MarketCap { get; set; }

        [JsonProperty("ConstituentCount")]
        public long ConstituentCount { get; set; }

        [JsonProperty("Variant")]
        public Variant Variant { get; set; }

        //[JsonProperty("Points")]
        //public long Points { get; set; }

        [JsonProperty("ListingCurrencyToUSD")]
        public double ListingCurrencyToUsd { get; set; }

        [JsonProperty("FxDate")]
        public DateTimeOffset FxDate { get; set; }

        [JsonProperty("DataStatusMask")]
        public string DataStatusMask { get; set; }

        [JsonProperty("PriceDate")]
        public DateTimeOffset PriceDate { get; set; }

        [JsonProperty("IndexID")]
        public long IndexId { get; set; }

        [JsonProperty("CalculationMask")]
        public long CalculationMask { get; set; }

        [JsonProperty("ExchangeName")]
        public ExchangeName ExchangeName { get; set; }

        [JsonProperty("PreviousClose")]
        public double PreviousClose { get; set; }

        [JsonProperty("MTDUnhedgedReturn")]
        public string MtdUnhedgedReturn { get; set; }

        [JsonProperty("MTDHedgeReturn")]
        public string MtdHedgeReturn { get; set; }

        [JsonProperty("MTDHedgeReturnWithAdjustment")]
        public string MtdHedgeReturnWithAdjustment { get; set; }

        [JsonProperty("UnderlyingIndexPositionAtAsAtDate")]
        public string UnderlyingIndexPositionAtAsAtDate { get; set; }

        [JsonProperty("UnderlyingRic")]
        public string UnderlyingRic { get; set; }
    }

    public partial class IndexProperty
    {
        [JsonProperty("DividendReinvestmentMethod")]
        public string DividendReinvestmentMethod { get; set; }

        [JsonProperty("DividendReinvestmentSchedule")]
        public string DividendReinvestmentSchedule { get; set; }

        [JsonProperty("SpecialDividendReinvestmentStrategy")]
        public string SpecialDividendReinvestmentStrategy { get; set; }

        [JsonProperty("SpecialDividendReinvestmentSchedule")]
        public string SpecialDividendReinvestmentSchedule { get; set; }
    }

    public partial class Listing
    {
        [JsonProperty("ListingID")]
        public long ListingId { get; set; }

        [JsonProperty("Name")]
        public Name Name { get; set; }

        [JsonProperty("Variant")]
        public Variant Variant { get; set; }

        [JsonProperty("Bloomberg")]
        public string Bloomberg { get; set; }

        [JsonProperty("ExchangeTicker")]
        public string ExchangeTicker { get; set; }

        [JsonProperty("Isin")]
        public Isin? Isin { get; set; }

        [JsonProperty("Cusip")]
        public object Cusip { get; set; }

        [JsonProperty("Ric")]
        public string Ric { get; set; }

        [JsonProperty("ListingCurrency")]
        public string ListingCurrency { get; set; }

        [JsonProperty("Mic")]
        public Mic Mic { get; set; }

        [JsonProperty("ExchangeName")]
        public ExchangeName ExchangeName { get; set; }

        [JsonProperty("Sedol")]
        public object Sedol { get; set; }

        [JsonProperty("Other")]
        public object Other { get; set; }
    }

    public enum ConstituentType { Normal, Detached };

    public enum Currency { Eur, GBP, CHF, DKK, NOK, USD, SEK, PLN, ZAR };

    public enum ConstituentSecurityType { CommonStock, Right, Funds };

    public enum ExchangeName { None, Eurex,XETRA, EURONEXT, ESP , SIX};

    public enum Isin { Eu0009658145, QS0011131834, FR0003500008 , QS0011131826 , DE0008469008, IT0003465736, QS0011131990, QS0011211156, NL0000000107, GB0001383545, ES0SI0000005, CH0009980894, EU0009658202, EU0009658434, EU0009659275, EU0009658426, EU0009659267, GB00BNNLHW18, CH0102792253, CH0147789777, CH0020751605, CH0020751647, CH0020751589, CH0020751639, US78378X1072, CH0102630834, GB00BNNLHY32, GB00B56DPW49 };

    public enum Mic { None , XPAR, XETR, XAMS, XMCE, XVTX};

    public enum Name { EuroStoxx50Index , CAC40 , DAX, FTSEMIB, AEX , UKX, IBEX, SMI , MSCI_Europe, STOXXEUROPE600, EUROSTOXXBANKS, EUROSTOXXSELECTDIVIDEND30, SPX, CAC60LARGETEQUALWEIGHTED };

    public enum IndexPositionSecurityType { Index };

    public enum Variant { Gross, Net, Price };

    public partial class MarkitCompositionObject
    {
        public static MarkitCompositionObject FromJson(string json) => JsonConvert.DeserializeObject<MarkitCompositionObject>(json, MarkitComposition.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this MarkitCompositionObject self) => JsonConvert.SerializeObject(self, MarkitComposition.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ConstituentTypeConverter.Singleton,
                CurrencyConverter.Singleton,
                ConstituentSecurityTypeConverter.Singleton,
                ExchangeNameConverter.Singleton,
                IsinConverter.Singleton,
                MicConverter.Singleton,
                NameConverter.Singleton,
                IndexPositionSecurityTypeConverter.Singleton,
                VariantConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class ConstituentTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ConstituentType) || t == typeof(ConstituentType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Normal":
                    return ConstituentType.Normal;
                case "Detached":
                    return ConstituentType.Detached;
            }
            throw new Exception("Cannot unmarshal type ConstituentType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ConstituentType)untypedValue;
            switch (value)
            {
                case ConstituentType.Normal:
                    serializer.Serialize(writer, "Normal");
                    return;
                case ConstituentType.Detached:
                    serializer.Serialize(writer, "Detached");
                    return;
            }
            throw new Exception("Cannot marshal type ConstituentType");
        }

        public static readonly ConstituentTypeConverter Singleton = new ConstituentTypeConverter();
    }

    internal class CurrencyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Currency) || t == typeof(Currency?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EUR":
                    return Currency.Eur;
                case "GBX":
                    return Currency.GBP;
                case "GBP":
                    return Currency.GBP;
                case "CHF":
                    return Currency.CHF;
                case "DKK":
                    return Currency.DKK;
                case "NOK":
                    return Currency.NOK;
                case "USD":
                    return Currency.USD;
                case "SEK":
                    return Currency.SEK;
                case "PLN":
                    return Currency.PLN;
                case "ZAC":
                    return Currency.ZAR;
                case "ZAR":
                    return Currency.ZAR;
            }
            throw new Exception("Cannot unmarshal type Currency");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Currency)untypedValue;
            switch (value)
            {
                case Currency.Eur:
                    serializer.Serialize(writer, "EUR");
                    return;
                case Currency.GBP:
                    serializer.Serialize(writer, "GBP");
                    return;
                case Currency.CHF:
                    serializer.Serialize(writer, "CHF");
                    return;
                case Currency.DKK:
                    serializer.Serialize(writer, "DKK");
                    return;
                case Currency.NOK:
                    serializer.Serialize(writer, "NOK");
                    return;
                case Currency.USD:
                    serializer.Serialize(writer, "USD");
                    return;
                case Currency.SEK:
                    serializer.Serialize(writer, "SEK");
                    return;
                case Currency.PLN:
                    serializer.Serialize(writer, "PLN");
                    return;
                case Currency.ZAR:
                    serializer.Serialize(writer, "ZAR");
                    return;
            }
            throw new Exception("Cannot marshal type Currency");
        }

        public static readonly CurrencyConverter Singleton = new CurrencyConverter();
    }

    internal class ConstituentSecurityTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ConstituentSecurityType) || t == typeof(ConstituentSecurityType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Common Stock": 
                    return ConstituentSecurityType.CommonStock;
                case "GDR":
                    return ConstituentSecurityType.CommonStock;
                case "Right":
                    return ConstituentSecurityType.Right;
                case "Funds":
                    return ConstituentSecurityType.Funds;
            }
            throw new Exception("Cannot unmarshal type ConstituentSecurityType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ConstituentSecurityType)untypedValue;
            switch (value)
            {

                case ConstituentSecurityType.CommonStock: 
                serializer.Serialize(writer, "Common Stock");
                return;
                case ConstituentSecurityType.Right:
                    serializer.Serialize(writer, "Right");
                    return;
                case ConstituentSecurityType.Funds:
                    serializer.Serialize(writer, "Funds");
                    return;
            }
            throw new Exception("Cannot marshal type ConstituentSecurityType");
        }

        public static readonly ConstituentSecurityTypeConverter Singleton = new ConstituentSecurityTypeConverter();
    }

    internal class ExchangeNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExchangeName) || t == typeof(ExchangeName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "NYSE EURONEXT - EURONEXT PARIS":
                    return ExchangeName.Eurex;
                case "None":
                    return ExchangeName.None;
                case "XETRA":
                    return ExchangeName.XETRA;
                case "NYSE EURONEXT - EURONEXT AMSTERDAM":
                    return ExchangeName.EURONEXT;
                case "MERCADO CONTINUO ESPANOL":
                    return ExchangeName.ESP;
                case "SIX SWISS EXCHANGE AG":
                    return ExchangeName.SIX;



            }
            throw new Exception("Cannot unmarshal type ExchangeName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExchangeName)untypedValue;
            switch (value)
            {
                case ExchangeName.None:
                    serializer.Serialize(writer, "None");
                    return;
                case ExchangeName.Eurex:
                    serializer.Serialize(writer, "NYSE EURONEXT - EURONEXT PARIS");
                    return;
                case ExchangeName.XETRA:
                    serializer.Serialize(writer, "XETRA");
                    return;
                case ExchangeName.EURONEXT:
                    serializer.Serialize(writer, "NYSE EURONEXT - EURONEXT AMSTERDAM");
                    return;
                case ExchangeName.ESP:
                    serializer.Serialize(writer, "MERCADO CONTINUO ESPANOL");
                    return;
                case ExchangeName.SIX:
                    serializer.Serialize(writer, "SIX SWISS EXCHANGE AG");
                    return;
                   
            }
            throw new Exception("Cannot marshal type ExchangeName");
        }

        public static readonly ExchangeNameConverter Singleton = new ExchangeNameConverter();
    }

    internal class IsinConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Isin) || t == typeof(Isin?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EU0009658145":
                    return Isin.Eu0009658145;
                case "QS0011131834":
                    return Isin.QS0011131834;
                case "FR0003500008":
                    return Isin.FR0003500008;
                case "QS0011131826":
                    return Isin.QS0011131826;
                case "DE0008469008":
                    return Isin.DE0008469008;
                case "IT0003465736":
                    return Isin.IT0003465736;
                case "QS0011131990":
                    return Isin.QS0011131990;
                case "QS0011211156":
                    return Isin.QS0011211156;
                case "NL0000000107":
                    return Isin.NL0000000107;
                case "GB0001383545":
                    return Isin.GB0001383545;
                case "ES0SI0000005":
                    return Isin.ES0SI0000005;
                case "CH0009980894":
                    return Isin.CH0009980894;
                case "EU0009658202":
                    return Isin.EU0009658202;
                case "EU0009658434":
                    return Isin.EU0009658434;
                case "EU0009659275":
                    return Isin.EU0009659275;
                case "EU0009658426":
                    return Isin.EU0009658426;
                case "EU0009659267":
                    return Isin.EU0009659267;
                case "GB00BNNLHW18":
                    return Isin.GB00BNNLHW18;
                case "CH0102792253":
                    return Isin.CH0102792253;
                case "CH0147789777":
                    return Isin.CH0147789777;
                case "CH0020751605":
                    return Isin.CH0020751605;
                case "CH0020751647":
                    return Isin.CH0020751647;
                case "CH0020751589":
                    return Isin.CH0020751589;
                case "CH0020751639":
                    return Isin.CH0020751639;
                case "US78378X1072":
                    return Isin.US78378X1072;
                case "CH0102630834":
                    return Isin.CH0102630834;
                case "GB00BNNLHY32":
                    return Isin.GB00BNNLHY32;
                case "GB00B56DPW49":
                    return Isin.GB00B56DPW49;
                    




            }
            throw new Exception("Cannot unmarshal type Isin");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Isin)untypedValue;
            switch (value)
            {
                case Isin.Eu0009658145:
                    serializer.Serialize(writer, "EU0009658145");
                    return;
                case Isin.QS0011131834:
                    serializer.Serialize(writer, "QS0011131834");
                    return;
                case Isin.FR0003500008:
                    serializer.Serialize(writer, "FR0003500008");
                    return;
                case Isin.QS0011131826:
                    serializer.Serialize(writer, "QS0011131826");
                    return;
                case Isin.DE0008469008:
                    serializer.Serialize(writer, "DE0008469008");
                    return;
                case Isin.IT0003465736:
                    serializer.Serialize(writer, "IT0003465736");
                    return;
                case Isin.QS0011131990:
                    serializer.Serialize(writer, "QS0011131990");
                    return;
                case Isin.QS0011211156:
                    serializer.Serialize(writer, "QS0011211156");
                    return;
                case Isin.NL0000000107:
                    serializer.Serialize(writer, "NL0000000107");
                    return;
                case Isin.GB0001383545:
                    serializer.Serialize(writer, "GB0001383545");
                    return;
                case Isin.ES0SI0000005:
                    serializer.Serialize(writer, "ES0SI0000005");
                    return;
                case Isin.CH0009980894:
                    serializer.Serialize(writer, "CH0009980894");
                    return;
                case Isin.EU0009658202:
                    serializer.Serialize(writer, "EU0009658202");
                    return;
                case Isin.EU0009658434:
                    serializer.Serialize(writer, "EU0009658434");
                    return;
                case Isin.EU0009659275:
                    serializer.Serialize(writer, "EU0009659275");
                    return;
                case Isin.EU0009658426:
                    serializer.Serialize(writer, "EU0009658426");
                    return;
                case Isin.EU0009659267:
                    serializer.Serialize(writer, "EU0009659267");
                    return;
                case Isin.GB00BNNLHW18:
                    serializer.Serialize(writer, "GB00BNNLHW18");
                    return;
                case Isin.CH0102792253:
                    serializer.Serialize(writer, "CH0102792253");
                    return;
                case Isin.CH0147789777:
                    serializer.Serialize(writer, "CH0147789777");
                    return;
                case Isin.CH0020751605:
                    serializer.Serialize(writer, "CH0020751605");
                    return;
                case Isin.CH0020751647:
                    serializer.Serialize(writer, "CH0020751647");
                    return;
                case Isin.CH0020751589:
                    serializer.Serialize(writer, "CH0020751589");
                    return;
                case Isin.CH0020751639:
                    serializer.Serialize(writer, "CH0020751639");
                    return;
                case Isin.US78378X1072:
                    serializer.Serialize(writer, "US78378X1072");
                    return;
                case Isin.CH0102630834:
                    serializer.Serialize(writer, "CH0102630834");
                    return;
                case Isin.GB00BNNLHY32:
                    serializer.Serialize(writer, "GB00BNNLHY32");
                    return;
                case Isin.GB00B56DPW49:
                    serializer.Serialize(writer, "GB00B56DPW49");
                    return;
                    

            }

            throw new Exception("Cannot marshal type Isin");
        }

        public static readonly IsinConverter Singleton = new IsinConverter();
    }

    internal class MicConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Mic) || t == typeof(Mic?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "NONE":
                    return Mic.None;
                case "XPAR":
                    return Mic.XPAR;
                case "XETR":
                    return Mic.XETR;
                case "XAMS":
                    return Mic.XAMS;
                case "XMCE":
                    return Mic.XMCE;
                case "XVTX":
                    return Mic.XVTX;

            }
            throw new Exception("Cannot unmarshal type Mic");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Mic)untypedValue;
            switch (value)
            {
                case Mic.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case Mic.XPAR:
                    serializer.Serialize(writer, "XPAR");
                    return;
                case Mic.XETR:
                    serializer.Serialize(writer, "XETR");
                    return;
                case Mic.XAMS:
                    serializer.Serialize(writer, "XAMS");
                    return;
                case Mic.XMCE:
                    serializer.Serialize(writer, "XMCE");
                    return;
                case Mic.XVTX:
                    serializer.Serialize(writer, "XVTX");
                    return;

            }
            throw new Exception("Cannot marshal type Mic");
        }

        public static readonly MicConverter Singleton = new MicConverter();
    }

    internal class NameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Name) || t == typeof(Name?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EURO STOXX 50 INDEX":
                    return Name.EuroStoxx50Index;
                case "CAC40":
                    return Name.CAC40;
                case "DAX PERFORMANCE-INDEX TR":
                    return Name.DAX;
                case "FTSE MIB":
                    return Name.FTSEMIB;
                case "AEX-INDEX":
                    return Name.AEX;
                case "FTSE 100":
                    return Name.UKX;
                case "IBEX 35":
                    return Name.IBEX;
                case "SWX SMI":
                    return Name.SMI;
                case "EUROPE-990500":
                    return Name.MSCI_Europe;
                case "STOXX EUROPE 600":
                    return Name.STOXXEUROPE600;
                case "EURO STOXX BANKS":
                    return Name.EUROSTOXXBANKS;
                case "EURO STOXX SELECT DIVIDEND 30":
                    return Name.EUROSTOXXSELECTDIVIDEND30;
                case "S&P 500":
                    return Name.SPX;
                case "CAC 60 LARGET EQUAL WEIGHTED":
                    return Name.CAC60LARGETEQUALWEIGHTED;
                    


            }
            throw new Exception("Cannot unmarshal type Name");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Name)untypedValue;
            switch (value)
            {
                case Name.EuroStoxx50Index:
                    serializer.Serialize(writer, "EURO STOXX 50 INDEX");
                    return;
                case Name.CAC40:
                    serializer.Serialize(writer, "CAC40");
                    return;
                case Name.DAX:
                    serializer.Serialize(writer, "DAX PERFORMANCE - INDEX TR");
                    return;
                case Name.FTSEMIB:
                    serializer.Serialize(writer, "FTSE MIB");
                    return;
                case Name.AEX:
                    serializer.Serialize(writer, "AEX-INDEX");
                    return;
                case Name.UKX:
                    serializer.Serialize(writer, "FTSE 100");
                    return;
                case Name.IBEX:
                    serializer.Serialize(writer, "IBEX 35");
                    return;
                case Name.SMI:
                    serializer.Serialize(writer, "SWX SMI");
                    return;
                case Name.MSCI_Europe:
                    serializer.Serialize(writer, "EUROPE-990500");
                    return;
                case Name.STOXXEUROPE600:
                    serializer.Serialize(writer, "STOXX EUROPE 600");
                    return;
                case Name.EUROSTOXXBANKS:
                    serializer.Serialize(writer, "EURO STOXX BANKS");
                    return;
                case Name.EUROSTOXXSELECTDIVIDEND30:
                    serializer.Serialize(writer, "EURO STOXX SELECT DIVIDEND 30");
                    return;
                case Name.SPX:
                    serializer.Serialize(writer, "S&P 500");
                    return;
                case Name.CAC60LARGETEQUALWEIGHTED:
                    serializer.Serialize(writer, "CAC 60 LARGET EQUAL WEIGHTED");
                    return;
            }
            throw new Exception("Cannot marshal type Name");
        }

        public static readonly NameConverter Singleton = new NameConverter();
    }

    internal class IndexPositionSecurityTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(IndexPositionSecurityType) || t == typeof(IndexPositionSecurityType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Index")
            {
                return IndexPositionSecurityType.Index;
            }
            throw new Exception("Cannot unmarshal type IndexPositionSecurityType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (IndexPositionSecurityType)untypedValue;
            if (value == IndexPositionSecurityType.Index)
            {
                serializer.Serialize(writer, "Index");
                return;
            }
            throw new Exception("Cannot marshal type IndexPositionSecurityType");
        }

        public static readonly IndexPositionSecurityTypeConverter Singleton = new IndexPositionSecurityTypeConverter();
    }

    internal class VariantConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Variant) || t == typeof(Variant?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Gross":
                    return Variant.Gross;
                case "Net":
                    return Variant.Net;
                case "Price":
                    return Variant.Price;
            }
            throw new Exception("Cannot unmarshal type Variant");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Variant)untypedValue;
            switch (value)
            {
                case Variant.Gross:
                    serializer.Serialize(writer, "Gross");
                    return;
                case Variant.Net:
                    serializer.Serialize(writer, "Net");
                    return;
                case Variant.Price:
                    serializer.Serialize(writer, "Price");
                    return;
            }
            throw new Exception("Cannot marshal type Variant");
        }

        public static readonly VariantConverter Singleton = new VariantConverter();
    }
}
